# antifungal/design.py
import numpy as np
import random
import pandas as pd
from .predict import predict_MIC
from .ChemoinfoPy.ProteinTools import calc_Pro_Des_values, calc_Pro_Des
from modlamp.descriptors import GlobalDescriptor
from scipy.optimize import minimize, NonlinearConstraint

class segment():
    """
    A class for segmenting peptide sequences into subpeptides.

    Attributes:
        sequence (str): The peptide sequence to be segmented.
        min_size (int): Minimum size for each subpeptide segment. Default is 11.
        subpeptides (list): List of segmented subpeptides.
        start_end (list): List of starting and ending positions for each subpeptide.
        seq_name (list): List of names assigned to each subpeptide.

    Methods:
        get_segmented_sequences(): Segments the peptide into subpeptides.
        predict(): Predicts the antifungal activity of all subpeptides.
    """

    def __init__(self, sequence, min_size=11):
        """
        Constructs all the necessary attributes for the segment object.

        Args:
            sequence (str): The peptide sequence to be segmented.
            min_size (int, optional): Minimum size for each subpeptide segment. Default is 11.
        """
        self.sequence = sequence
        self.min_size = min_size

    def get_segmented_sequences(self):
        """
        Segments the peptide into subpeptides with a minimum length of 'min_size'.

        Returns:
            self: The instance itself with updated 'subpeptides', 'start_end', and 'seq_name' attributes.
        """
        sequence = self.sequence
        min_size = self.min_size
        start_end = []
        subpeptides = []
        for i in range(0, len(sequence) - min_size + 1):
            for j in range(i + min_size, len(sequence) + 1):
                if j == len(sequence):
                    subpeptides.append(sequence[i:])
                else:
                    subpeptides.append(sequence[i:j])
                start_end.append([i+1, j])
        self.subpeptides = subpeptides
        self.start_end = start_end
        self.seq_name = ["segment_" + str(i) + "_" + str(j) for i, j  in self.start_end]
        return self

    def predict(self):
        """
        Predicts the antifungal activity of all subpeptides generated by 'get_segmented_sequences'.

        Returns:
            DataFrame: A pandas DataFrame containing predictions for each subpeptide.
        """

        predictions = predict_MIC(self.subpeptides)
        predictions["seq_name"] = self.seq_name
        return predictions


class single_point_mutation():
    """
    A class for generating and predicting the antifungal activity of all sequences with exhaustive single point mutations.

    Attributes:
        standard_AA (list): List of standard amino acids.
        original_sequence (str): The original peptide sequence.
        original_sequence_activity (DataFrame): Predicted antifungal activity of the original sequence.
        mutated_sequences (list): List of all possible mutated sequences.
        mutated_positions (list): Positions of mutation in each mutated sequence.
        mutated_AA (list): Amino acid used for mutation in each mutated sequence.
        seq_name (list): List of names assigned to each mutated sequence.

    Methods:
        get_mutated_sequences(): Generates all possible single point mutations of the sequence.
        predict(): Predicts the antifungal activity of all mutated sequences.
    """
    def __init__(self, sequence):
        """
        Constructs all the necessary attributes for the single_point_mutation object.

        Args:
            sequence (str): The peptide sequence for mutation analysis.
        """
        self.standard_AA = ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L',
                            'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y']
        self.original_sequence = sequence
        self.original_sequence_activity = predict_MIC(sequence)

    def get_mutated_sequences(self):
        """
        Generates all possible mutated sequences through single point mutation of the original sequence.

        Returns:
            self: The instance itself with updated 'mutated_sequences', 'mutated_positions', 'mutated_AA', and 'seq_name' attributes.
        """
        mutated_sequences = []
        mutated_positions = []
        mutated_AA = []

        for index, amino_acid in enumerate(self.original_sequence):
            for mutation in self.standard_AA:
                if mutation != amino_acid:
                    mut_seq = list(self.original_sequence)
                    mut_seq[index] = mutation
                    mutated_sequences.append("".join(mut_seq))
                    mutated_positions.append(index + 1)
                    mutated_AA.append(mutation)

        self.mutated_sequences = mutated_sequences
        self.mutated_positions = mutated_positions
        self.mutated_AA = mutated_AA
        self.seq_name = ["mutate_" + str(i) +"_"+ AA for i, AA in zip(self.mutated_positions, self.mutated_AA)]
        return self

    def predict(self):
        """
        Predicts the antifungal activity of all mutated sequences generated by 'get_mutated_sequences'.

        Returns:
            DataFrame: A pandas DataFrame containing predictions for each mutated sequence.
        """
        predictions = predict_MIC(self.mutated_sequences)
        predictions["seq_name"] = self.seq_name
        return predictions




class global_optimization():
    """
    A class for performing global optimization on a peptide sequence to enhance its properties such as antifungal activity.

    Attributes:
        sequence (str): The input peptide sequence.
        seed (int): Seed value for random number generation, used in optimization process.

    Methods:
        cost(seq_nums): Computes the cost (e.g., antifungal activity) of a sequence.
        constraint(seq_nums, const): Applies a specified constraint to a sequence.
        transfer_alphabeta_num(seq): Converts a sequence from alphabet to numerical representation.
        trasfer_num_alphabeta(numbers): Converts a sequence from numerical to alphabet representation.
        softmax(x): Applies the softmax function to an array.
        optimize(constraintName, constraint_lb_tol_percent, constraint_ub_tol_percent, maxiter): Performs global optimization with specified constraints and parameters.
    """

    def __init__(self, sequence, seed=0):
        """
        Initializes the global_optimization object with a sequence and a seed for random number generation.

        Args:
            sequence (str): The input peptide sequence.
            seed (int, optional): Seed value for random number generation. Defaults to 0.
        """
        self.sequence = sequence
        self.seed = seed

    def cost(self, seq_nums):
        """
        Calculates the cost (e.g., antifungal activity index) of a sequence in numerical form.

        Args:
            seq_nums (numpy.ndarray): Numerical representation of the peptide sequence.

        Returns:
            float: Cost of the sequence, representing its antifungal activity.
        """
        sequence = self.trasfer_num_alphabeta(seq_nums)
        sequence_activity = predict_MIC(sequence)
        return sequence_activity["AFI"]

    def constraint(self, seq_nums, const):
        """
        Applies a specified constraint to a sequence.

        Args:
            seq_nums (numpy.ndarray): Numerical representation of the sequence.
            const (str): The constraint to be applied (e.g., molecular weight 'MW', charge 'Charge').

        Returns:
            float: The value of the constraint for the sequence.

        Raises:
            ValueError: If an invalid constraint is specified.
        """
        seq = self.trasfer_num_alphabeta(seq_nums)
        DesObject = GlobalDescriptor(seq)
        # ['MW', 'Charge', 'ChargeDensity', 'pI', 'InstabilityInd', 'Aromaticity', 'AliphaticInd', 'BomanInd', 'HydrophRatio']
        if const == 'MW':
            DesObject.calculate_MW(amide=True)
        elif const == 'Charge':
            DesObject.calculate_charge(ph=7.4, amide=True)
        elif const == 'ChargeDensity':
            DesObject.charge_density(ph=7.4, amide=True)
        elif const == 'pI':
            DesObject.isoelectric_point(amide=True)
        elif const == 'InstabilityInd':
            DesObject.instability_index()
        elif const == 'Aromaticity':
            DesObject.aromaticity()
        elif const == 'AliphaticInd':
            DesObject.aliphatic_index()
        elif const == 'BomanInd':
            DesObject.boman_index()
        elif const == 'HydrophRatio':
            DesObject.hydrophobic_ratio()
        else:
            raise ValueError(
                "The constraint is not valid, please choose from ['MW', 'Charge', 'ChargeDensity', 'pI', 'InstabilityInd', 'Aromaticity', 'AliphaticInd', 'BomanInd', 'HydrophRatio']")
        return DesObject.descriptor[0][0]

    def transfer_alphabeta_num(self, seq):
        """
        Converts a sequence from alphabet (amino acid) to numerical (one-hot encoding) representation.

        Args:
            seq (str): Alphabet representation of the sequence.

        Returns:
            numpy.ndarray: Numerical representation of the sequence.
        """
        # one hot encoding
        standard_AA = ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y']
        encoded_seq = []
        for i, seq_aa in enumerate(seq):
            encoded_aa = [1.0 if seq_aa == standard_aa else 0.0 for standard_aa in standard_AA]
            encoded_seq.append(encoded_aa)
        return np.array(encoded_seq).flatten()

    def trasfer_num_alphabeta(self, numbers):
        """
        Converts a sequence from numerical to alphabet representation.

        Args:
            numbers (numpy.ndarray): Numerical representation of the sequence.

        Returns:
            str: Alphabet representation of the sequence.
        """
        standard_AA = ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y']
        reshped_num = numbers.reshape(-1, len(standard_AA))
        seq = []
        for i in range(reshped_num.shape[0]):
            reshped_num[i, :] = self.softmax(reshped_num[i, :])
            idx = np.argmax(reshped_num[i, :])
            seq.append(standard_AA[idx])
        return "".join(seq)

    def softmax(self, x):
        """
        Applies the softmax function to an array, commonly used in machine learning for classification.

        Args:
            x (numpy.ndarray): The input array.

        Returns:
            numpy.ndarray: The array after applying the softmax function.
        """
        a = np.exp(x)
        b = np.sum(np.exp(x))
        return a / b

    def optimize(self, constraintName=None, constraint_lb_tol_percent=0.9, constraint_ub_tol_percent=1.1, maxiter=1000):
        """
        Performs global optimization on the sequence with optional constraints.

        Args:
            constraintName (str, optional): The name of the constraint to be applied during optimization.
            constraint_lb_tol_percent (float, optional): Lower bound tolerance percentage for the constraint.
            constraint_ub_tol_percent (float, optional): Upper bound tolerance percentage for the constraint.
            maxiter (int, optional): Maximum number of iterations for the optimization process.

        Returns:
            tuple: A tuple containing the optimized sequence and a dictionary of results including optimized sequence, antifungal index, and any applied constraint.

        Raises:
            ValueError: If an invalid constraint is specified.
        """
        if constraintName is None:
            # nlc = None
            nlc = ()

        elif constraintName in ['MW', 'Charge', 'ChargeDensity', 'pI', 'InstabilityInd', 'Aromaticity', 'AliphaticInd',
                                'BomanInd', 'HydrophRatio']:
            lb = self.constraint(self.transfer_alphabeta_num(self.sequence), constraintName) * constraint_lb_tol_percent
            ub = self.constraint(self.transfer_alphabeta_num(self.sequence), constraintName) * constraint_ub_tol_percent
            nlc = NonlinearConstraint(lambda seq_num: self.constraint(seq_num, constraintName), lb, ub)

        else:
            raise ValueError(
                "The constraint is not valid, please choose from ['MW', 'Charge', 'ChargeDensity', 'pI', 'InstabilityInd', 'Aromaticity', 'AliphaticInd', 'BomanInd', 'HydrophRatio']")

        # minimize
        minimization = minimize(self.cost,
                                x0=self.transfer_alphabeta_num(self.sequence),
                                method='COBYLA',
                                constraints=nlc,
                                options={'maxiter': maxiter, 'disp': False})
        optimized_seq = self.trasfer_num_alphabeta(minimization.x)

        if constraintName is None:
            dict_result = {'optimized_seq': optimized_seq,
                           'antifungal_idx': self.cost(minimization.x)}
        elif constraintName in ['MW', 'Charge', 'ChargeDensity', 'pI', 'InstabilityInd', 'Aromaticity', 'AliphaticInd',
                                'BomanInd', 'HydrophRatio']:
            dict_result = {'optimized_seq': optimized_seq,
                           'antifungal_idx': self.cost(minimization.x),
                           'constraintName': constraintName,
                           'constraint': self.constraint(minimization.x, constraintName)}

        return optimized_seq, dict_result
    

if __name__ == "__main__":
    seq = 'HIHIRHMWLLRR'

    # Testing the segment class
    print("Testing segment class...")
    segment_instance = segment(seq)
    segment_instance.get_segmented_sequences()
    segment_predictions = segment_instance.predict()
    print(f"Segment predictions:\n{segment_predictions}\n")

    # Testing the single_point_mutation class
    print("Testing single_point_mutation class...")
    mutation_instance = single_point_mutation(seq)
    mutation_instance.get_mutated_sequences()
    mutation_predictions = mutation_instance.predict()
    print(f"Mutation predictions:\n{mutation_predictions}\n")

    # Testing the global_optimization class
    print("Testing global_optimization class...")
    optimization_instance = global_optimization(seq)
    optimized_sequence, optimization_results = optimization_instance.optimize(constraintName='MW')
    print(f"Optimized sequence: {optimized_sequence}")
    print(f"Optimization results:\n{optimization_results}\n")